ylim = c(0,2), lwd = w,col=1,main='(A)')
lines(x, f0, lty = 2, lwd = w,col=2)
lines(x, f1, lty = 3, lwd = w,col=3)
lines(x, f2, lty = 4, lwd = w,col=4)
legend("topright", legend = gs,
lty = 1:4, lwd = w, inset = 0.02,col=1:4)
#figure (b)
plot(x, g/f0, type = "l", ylab = "",
ylim = c(0,3.2), lwd = w, lty = 2,col=2,main='(B)')
lines(x, g/f1, lty = 3, lwd = w,col=3)
lines(x, g/f2, lty = 4, lwd = w,col=4)
legend("topright", legend = gs[-1],
lty = 2:4, lwd = w, inset = 0.02,col=2:4)
library(knitr)
m <- 1000
est <- sd <- numeric(3)
g <- function(x) {
exp(-x^2/2) * x^2/ sqrt(2*pi)
}
x <- runif(m) #using f0
fg <- g(x)
est[1] <- mean(fg)
sd[1] <- sd(fg)
x <- runif(m) #using f1
fg <- g(x) / (x*exp(-x^2/2)/exp(1)^(-1/2))
est[2] <- mean(fg)
sd[2] <- sd(fg)
x <- runif(m) #using f2
fg <- g(x) / (x^(-6/5)/5)
est[3] <- mean(fg)
sd[3] <- sd(fg)
res <- rbind(est=round(est,3), sd=round(sd,3))
colnames(res) <- paste0('f',0:2)
kable(res)
n <- 1000
u <- runif(n)
x <- sqrt(-2* log(1-u+u/sqrt(exp(1))))
theta <- 1/2-mean(x)/sqrt(2*pi)*(1-1/sqrt(exp(1))) #根据原公式计算值
print(theta)
n <- 20
s <- 0
x1 <- numeric(1000)
x2 <- numeric(1000)
alpha <- .05
for (i in 1:1000){
x <- rchisq(n,df=2)
x1[i] <- mean(x)- qt(1-alpha/2,df=n-1)*sd(x)/sqrt(n)
x2[i] <- mean(x)+ qt(1-alpha/2,df=n-1)*sd(x)/sqrt(n)
if (x1[i] < 2  && 2< x2[i])
s <- s+1
}
print(s/1000)
set.seed(12)
n <- 100 #任意抽取n个样本
alpha <- .05
mu0 <- 1 #经过推导，可以知道卡方的自由度=均值
m <- 1000
p <- numeric(m)
for (j in 1:m) {
x <- rchisq(n, df=1)
ttest <- t.test(x, mu = mu0) #做检验
p[j] <- ttest$p.value
}
p.hat <- mean(p < alpha)
print(p.hat)
set.seed(12)
n <- 100
alpha <- .05
mu0 <- 1 #均匀分布的均值为(a+b)/2
m <- 1000
p <- numeric(m)
for (j in 1:m) {
x <- runif(n,0,2)
ttest <- t.test(x, mu = mu0)
p[j] <- ttest$p.value
}
p.hat <- mean(p < alpha)
print(p.hat)
set.seed(12)
n <- 100
alpha <- .05
mu0 <- 1 #指数分布的均值为1/lambda
m <- 10000
p <- numeric(m)
for (j in 1:m) {
x <- rexp(n, 1)
ttest <- t.test(x, mu = mu0)
p[j] <- ttest$p.value
}
p.hat <- mean(p < alpha)
print(p.hat)
set.seed(12)
n <- 100
alpha <- .05
mu0 <- 1 #指数分布的均值为1/lambda
m <- 1000
p <- numeric(m)
for (j in 1:m) {
x <- rexp(n, 1)
ttest <- t.test(x, mu = mu0)
p[j] <- ttest$p.value
}
p.hat <- mean(p < alpha)
print(p.hat)
library(MASS)
n <- c(10, 20, 30, 50)
m <- 100
d <- 3
c <- qchisq(0.95, d*(d+1)*(d+2)/6)
p.reject <- numeric(length(n))
funb1d <- function(x) {
xbar <- colMeans(x) #每一列的平均值
sigma <- cov(x)
b1d <- 0
for (p in 1:n[i]){
for (q in 1:n[i]){
b1d <- b1d +( (x[p,]-xbar) %*% solve(sigma) %*% (x[q,]-xbar)  )^3
}
}
b1d <- b1d/n[i]/6
return( b1d )
}
for (i in 1:length(n)) {
test <- numeric(m)
for (j in 1:m) {
x <- matrix(rnorm(n[i]*d), nrow = n[i], ncol = d)
test[j] <- as.integer(funb1d(x) >= c)
}
p.reject[i] <- mean(test)
}
p.reject
alpha <- .1
n <- 3
m <- 100
d <-3
epsilon <- c(seq(0, 0.15, .01),seq(0.15, 1, .05))
N <- length(epsilon)
pw <- numeric(N)
c <- qchisq(1-alpha, d*(d+1)*(d+2)/6)
funb1d <- function(x) { #原本的
xbar <- colMeans(x) #每一列的平均值
COV <- cov(x)
b1d <- 0
for (p in 1:n){
for (q in 1:n){
b1d <- b1d +( (x[p,]-xbar) %*% solve(COV) %*% (x[q,]-xbar)  )^3
}
}
b1d <- b1d/n/6
return(b1d )
}
for (j in 1:N) {
e <- epsilon[j]
test <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), replace = TRUE, size = n*d, prob = c(1-e, e))
x <- matrix(rnorm(n*d, 0, sigma), nrow = n, ncol = d)
test[i] <- as.integer(funb1d(x) >= c)
}
pw[j] <- mean(test)
}
alpha <- .1
n <- 30
m <- 100
d <-3
epsilon <- c(seq(0, 0.15, .01),seq(0.15, 1, .05))
N <- length(epsilon)
pw <- numeric(N)
c <- qchisq(1-alpha, d*(d+1)*(d+2)/6)
funb1d <- function(x) { #原本的
xbar <- colMeans(x) #每一列的平均值
COV <- cov(x)
b1d <- 0
for (p in 1:n){
for (q in 1:n){
b1d <- b1d +( (x[p,]-xbar) %*% solve(COV) %*% (x[q,]-xbar)  )^3
}
}
b1d <- b1d/n/6
return(b1d )
}
for (j in 1:N) {
e <- epsilon[j]
test <- numeric(m)
for (i in 1:m) {
sigma <- sample(c(1, 10), replace = TRUE, size = n*d, prob = c(1-e, e))
x <- matrix(rnorm(n*d, 0, sigma), nrow = n, ncol = d)
test[i] <- as.integer(funb1d(x) >= c)
}
pw[j] <- mean(test)
}
plot(epsilon, pw, type = "b", xlab = bquote(epsilon), ylim = c(0,1))
se <- sqrt(pw * (1-pw) / m)
lines(epsilon, pw+se, lty = 3)
lines(epsilon, pw-se, lty = 3)
library(bootstrap)
library(boot)
lam_hat <- eigen(cov(scor))$values
the_hat <- lam_hat[1] /sum(lam_hat) #原本的\theta统计量
B <- 50
the_b <- numeric(B)
func <- function(dat,d){
x <- dat[d,]
lam <- eigen(cov(scor[x,]))$values
the <- lam[1] /sum(lam)
return(the)
}
result <- boot(data = cbind(scor$mec,scor$vec,scor$alg,scor$ana,scor$sta),statistic = func,R=B)
the_b <- result$t
round(c(bias_boot=mean(the_b)-the_hat,se_boot=sqrt(var(the_b))),5)
n <- nrow(scor)
the_j <- rep(0,n)
for (i in 1:n){
x <- scor[-i,]
lam <- eigen(cov(x))$values
the_j[i] <- lam[1] /sum(lam)
}
bias_jack <- (n-1)*(mean(the_j)-the_hat)
se_jack <-  (n-1)*sqrt(var(the_j)/n)
round(c(bias_jack=(n-1)*(mean(the_j)-the_hat),se_jack=(n-1)*sqrt(var(the_j)/n)),5)
boot.ci(boot.out = result, conf = 0.95, type = c("perc","bca"))
mu<-0;n<-100;m<-1e3
library(boot)
set.seed(1)
func <- function(x,i){
xbar <- mean(x[i])
m3 <- mean((x - xbar)^3)
m2 <- mean((x - xbar)^2)
return( m3 / m2^1.5 )
}
ci.norm<-ci.basic<-ci.perc<-ci.bca<-matrix(NA,m,2)
for(i in 1:m){
x <-rnorm(n)
de <- boot(data=x,statistic=func, R = 999)
ci <- boot.ci(de,type=c("norm","basic","perc"))
ci.norm[i,]<-ci$norm[2:3];ci.basic[i,]<-ci$basic[4:5]
ci.perc[i,]<-ci$percent[4:5]
}
round(c(norm = mean(ci.norm[,1]<=mu & ci.norm[,2]>=mu),basic = mean(ci.basic[,1]<=mu & ci.basic[,2]>=mu),perc =mean(ci.perc[,1]<=mu & ci.perc[,2]>=mu),right.norm = sum(ci.norm[,1]>=mu)/m,left.norm = sum(ci.norm[,2]<=mu)/m,right.basic = sum(ci.basic[,1]>=mu)/m,left.basic = sum(ci.basic[,2]<=mu)/m,right.perc = sum(ci.perc[,1]>=mu)/m,left.perc= sum(ci.perc[,2]<=mu)/m ),4)
mu<-0;n<-100;m<-1e3
library(boot)
set.seed(1)
func <- function(x,i){
xbar <- mean(x[i])
m3 <- mean((x - xbar)^3)
m2 <- mean((x - xbar)^2)
return( m3 / m2^1.5 )
}
ci.norm<-ci.basic<-ci.perc<-ci.bca<-matrix(NA,m,2)
for(i in 1:m){
x <-rnorm(n)
de <- boot(data=x,statistic=func, R = 999)
ci <- boot.ci(de,type=c("norm","basic","perc"))
ci.norm[i,]<-ci$norm[2:3];ci.basic[i,]<-ci$basic[4:5]
ci.perc[i,]<-ci$percent[4:5]
}
round(c(norm = mean(ci.norm[,1]<=mu & ci.norm[,2]>=mu),basic = mean(ci.basic[,1]<=mu & ci.basic[,2]>=mu),perc =mean(ci.perc[,1]<=mu & ci.perc[,2]>=mu),right.norm = sum(ci.norm[,1]>=mu)/m,left.norm = sum(ci.norm[,2]<=mu)/m,right.basic = sum(ci.basic[,1]>=mu)/m,left.basic = sum(ci.basic[,2]<=mu)/m,right.perc = sum(ci.perc[,1]>=mu)/m,left.perc= sum(ci.perc[,2]<=mu)/m ),4)
devtools::build_vignettes()
devtools::build_vignettes()
v1 <- c(0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55)  #随意选取的数据
v2 <- c(1, 0.95, 0.95, 0.9, 0.85, 0.7, 0.65, 0.6, 0.55, 0.42)
m <- cor.test(v1, v2, alternative = "two.sided", method = "spearman", exact = FALSE)  #m为cor.test检验的结果
R <- 999
v <- c(v1,v2)
K <- 1:20
n <- length(v1)
set.seed(123)
reps <- numeric(R)
t0 <- cor(v1,v2,method = "spearman")
for (i in 1:R){                                        #做permutation test
k <- sample(K,size=n,replace=FALSE)
x1 <- v[k]
y1 <- v[-k]
reps[i] <- cor(x1,y1,method = "spearman")
}
p <- mean(abs(c(t0,reps)) >= abs(t0))
round(c(p,m$p.value),3)
library(RANN)
library(boot)
library(Ball)
library(energy)
m <- 100; k<-3; p<-2; set.seed(123)
n1 <- n2 <- 50; R<-999; n <- n1+n2; N = c(n1,n2)
Tn <- function(z, ix, sizes,k) {
n1 <- sizes[1]; n2 <- sizes[2]; n <- n1 + n2
if(is.vector(z)) z <- data.frame(z,0);
z <- z[ix, ];
NN <- nn2(data=z, k=k+1) # what's the first column?
block1 <- NN$nn.idx[1:n1,-1]
block2 <- NN$nn.idx[(n1+1):n,-1]
i1 <- sum(block1 < n1 + .5); i2 <- sum(block2 > n1+.5)
(i1 + i2) / (k * n)
}
eqdist.nn <- function(z,sizes,k){
boot.obj <- boot(data=z,statistic=Tn,R=R,sim = "permutation", sizes = sizes,k=k)
ts <- c(boot.obj$t0,boot.obj$t)
p.value <- mean(ts>=ts[1])
list(statistic=ts[1],p.value=p.value)
}
p.values <- matrix(NA,m,3)
for(i in 1:m){
x <- matrix(rnorm(n1*p,0,1),ncol=p);
y <- matrix(rnorm(n2*p,0,1.5),ncol=p);
z <- rbind(x,y)
p.values[i,1] <- eqdist.nn(z,N,k)$p.value
p.values[i,2] <- eqdist.etest(z,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=x,y=y,num.permutations=999,seed=i*12345)$p.value
}
pow <- colMeans(p.values<0.1) #alpha <- 0.1
print(pow)
m <- 100; k<-3; p<-2; set.seed(12345)
n1 <- n2 <- 50; R<-999; n <- n1+n2; N = c(n1,n2)
Tn <- function(z, ix, sizes,k) {
n1 <- sizes[1]; n2 <- sizes[2]; n <- n1 + n2
if(is.vector(z)) z <- data.frame(z,0);
z <- z[ix, ];
NN <- nn2(data=z, k=k+1) # what's the first column?
block1 <- NN$nn.idx[1:n1,-1]
block2 <- NN$nn.idx[(n1+1):n,-1]
i1 <- sum(block1 < n1 + .5); i2 <- sum(block2 > n1+.5)
(i1 + i2) / (k * n)
}
eqdist.nn <- function(z,sizes,k){
boot.obj <- boot(data=z,statistic=Tn,R=R,sim = "permutation", sizes = sizes,k=k)
ts <- c(boot.obj$t0,boot.obj$t)
p.value <- mean(ts>=ts[1])
list(statistic=ts[1],p.value=p.value)
}
p.values <- matrix(NA,m,3)
for(i in 1:m){
x <- matrix(rnorm(n1*p,1,1),ncol=p);
y <- matrix(rnorm(n2*p,1.3,1.5),ncol=p);
z <- rbind(x,y)
p.values[i,1] <- eqdist.nn(z,N,k)$p.value
p.values[i,2] <- eqdist.etest(z,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=x,y=y,num.permutations=999,seed=i*12345)$p.value
}
alpha <- 0.1;
pow <- colMeans(p.values<alpha)
print(pow)
devtools::build_vignettes()
install.packages('roxygen2',dependencies = TRUE)
devtools::build_vignettes()
k <- 3
a <- c(1,2)
d <- 2
norm_vec <- function(x) sqrt(sum(x^2)) #计算向量欧几里得范数
kth <- (-1)^k * norm_vec(a)^(2*k+2)/ factorial(k) / (2^k) / (2*k+1) / (2*k+2) * exp(lgamma((d+1)/2) + lgamma(k+3/2) - lgamma(k+d/2+1))
print(kth)
k <- 400
a <- c(1,2)
d <- 400
norm_vec <- function(x) sqrt(sum(x^2)) #计算向量欧几里得范数
kth <- (-1)^k * norm_vec(a)^(2*k+2) / factorial(k) / (2^k) / (2*k+1) / (2*k+2) * exp(lgamma((d+1)/2) + lgamma(k+3/2) - lgamma(k+d/2+1))
print(kth)
norm_vec <- function(x) sqrt(sum(x^2)) #计算向量欧几里得范数
kth <- function(k,a,d){
(-1)^k * norm_vec(a)^(2*k+2) / factorial(k) / (2^k) / (2*k+1) / (2*k+2) * exp(lgamma((d+1)/2) + lgamma(k+3/2) - lgamma(k+d/2+1))
}
sum <- 0
for(k in 1:200){
a <- c(1,1,3,4)
d <- 3
sum <- sum + kth(k,a,d)
}
print(sum)
norm_vec <- function(x) sqrt(sum(x^2)) #计算向量欧几里得范数
kth <- function(k,a,d){
(-1)^k * norm_vec(a)^(2*k+2) / factorial(k) / (2^k) / (2*k+1) / (2*k+2) * exp(lgamma((d+1)/2) + lgamma(k+3/2) - lgamma(k+d/2+1))
}
sum <- 0
for(k in 1:400){
a <- c(1,2)
d <- 2
sum <- sum + kth(k,a,d)
}
print(sum)
fun <- function(a,k) {
g1 <- function(u) (1+u^2/k)^(-(k+1)/2)
g2 <- integrate(g1,0,sqrt(a^2*(k)/(k+1-a^2)))$value
g <-  2*g2 * exp(lgamma((k+1)/2) -  lgamma(k/2) -log(sqrt(pi*k)))  #对gamma函数取对数
}
out <- rep(0,25)
i <- 1
for (k in c(4:25)){ #和11.4一样的范围
f <- function(a) fun(a,k-1)-fun(a,k)  #题目给定的方程
o <- uniroot(f ,c(0.01,sqrt(k)-0.3)) #对上下界进行一些限制
out[i] <- o$root
i <- i+1
}
i <- 23
for (k in c(100,500,1000)){
f <- function(a) fun(a,k-1)-fun(a,k)
o <- uniroot(f ,c(0.01,2))
out[i] <- o$root
i <- i+1
}
print(out)
devtools::build_vignettes()
devtools::build_vignettes()
t <- qua(100)
t <- qua95(100)
library(StatComp21015)
library(StatComp21015)
devtools::build_vignettes()
qua95 <- function(N){
rej1 <- list()
for (z in 1:N) {
EA <- matrix(0,100,100)
Q <- matrix(c(0.3,0.1,0.1,0.3), 2, 2)
z1 <- matrix(c(1,0),2,1)
z2 <- matrix(c(0,1),2,1)
EA[1:50, 1:50] <- matrix(t(z1) %*% Q %*% z1, 50, 50)
EA[51:100, 1:50] <- matrix(t(z2) %*% Q %*% z1, 50, 50)
EA[1:50, 51:100] <- matrix(t(z1) %*% Q %*% z2, 50, 50)
EA[51:100, 51:100] <- matrix(t(z2) %*% Q %*% z2, 50, 50)
A <- matrix(0,100,100)
for (i in 1:100){
for(j in 1:100){
A[i,j] <- rbinom(1,1,EA[i,j])
}
}
A1 <- A
A1[lower.tri(A1)] <- t(A1)[lower.tri(A1)]
A3 <- A1[-1,-1]
b <- A3[1,]
Nr1 <- length(which (b == 1, arr.ind = T))
Nr2 <- length(which (b == 0, arr.ind = T))
u <- (sqrt(Nr1-1)+sqrt(Nr2))^2
sigma <- sqrt(u)*{(1/sqrt(Nr1-1)+1/sqrt(Nr2))^(1/3)}
X1 <- matrix(rnorm(Nr1*Nr1,0,1),nrow=Nr1,ncol=Nr1)
diag(X1) <- rnorm(Nr1,0,2)
X1[lower.tri(X1)] <- t(X1)[lower.tri(X1)]
X1 <- X1/sqrt(Nr1)
X2 <- matrix(rnorm(Nr1*Nr2,0,1),nrow=Nr1,ncol=Nr2)
rt11 <- abs((max(eigen(t(X2) %*% X2)$values)-u)/sigma)
rt12 <- abs(max(eigen(X1)$values)-2)*Nr1^(2/3)
rej1[[z]] <- rt11+rt12
}
rej1<- as.vector(unlist(rej1))
new_rej12 <- rej1[order(rej1)][95]*2
return (new_rej12)
}
subg=function(A,L)
{
n=dim(A)[1]
C=B=matrix(rep(0,n^2),nrow=n)
if (L>1)
{
for (i in 1:(n-1))
for (j in (i+1):n)
if (A[1,i]==1&A[i,j]==1)
{B[i,j]=B[j,i]=1
} else   if (A[1,j]==1&A[i,j]==1)
{B[i,j]=B[j,i]=1
}
} else {B[1,]=A[1,]
B[,1]=A[1,]
}
if (L>2)
{
for (t in 3:L)
{
C=matrix(rep(0,n^2),nrow=n)
for (i in 2:(n-1))
for (j in (i+1):n)
if (B[i,j]==1)
{ a=(2:n)[-(i-1)]
C[i,a]=A[i,a]
C[a,i]=A[a,i]
a=(2:n)[-(j-1)]
C[j,a]=A[j,a]
C[a,j]=A[a,j]
}
B=B+C
for (i in 1:(n-1))
for (j in (i+1):n)
B[i,j]=B[j,i]=min(B[i,j],1)
}
}
return(B)
}
t <- qua95(100)
T
t
A <- matrix(c(0,1,1,1,0,1,1,1,0))
m <- subg(A,2)
print(t)
A <- matrix(c(0,1,1,1,0,1,1,1,0),3,3)
m <- subg(A,2)
m
A <- matrix(c(0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0),3,3)
m <- subg(A,2)
m
A <- matrix(c(0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0),4,4)
m <- subg(A,2)
m
t <- qua95(100)
A <- matrix(c(0,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0),6,6)
m <- subg(A,2)
A <- matrix(c(0,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0,0,1,1,,0),6,6)
A <- matrix(c(0,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0,0,1,1,0),6,6)
m <- subg(A,2)
m
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build(vignettes=FALSE)
q()
install.packages('../StatComp_1.0.tar.gz',repo=NULL)
install.packages('../StatComp21015_1.0.tar.gz',repo=NULL)
devtools::install_github("zhanghfd/statcomp",build_vignettes = TRUE, force=T)
devtools::install_github("zxy990409/StatComp21015",build_vignettes = TRUE, force=T)
